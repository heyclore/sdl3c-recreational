#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/keysym.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

#define SCREEN_W 800
#define SCREEN_H 600

#define MAP_W 8
#define MAP_H 8

// Simple grid map: 1 = wall, 0 = empty
int worldMap[MAP_H][MAP_W] = {
  {1,1,1,1,1,1,1,1},
  {1,0,0,0,0,0,0,1},
  {1,0,0,1,1,0,0,1},
  {1,0,0,0,0,0,0,1},
  {1,0,1,0,0,1,0,1},
  {1,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,1},
  {1,1,1,1,1,1,1,1}
};

typedef struct {
  double x, y;
  double dirX, dirY;
  double planeX, planeY;
} Camera;

typedef struct {
  unsigned int *pixels;
  XImage *img;
  int w, h;
} Framebuffer;

Camera cam = {
  3.5, 3.5,     // position
  -1.0, 0.0,    // direction
  0.0, 0.66     // camera plane (FOV)
};

Framebuffer fb;

void clear_fb() {
  memset(fb.pixels, 0, fb.w * fb.h * sizeof(unsigned int));
}

void draw_vertical(int x, int y0, int y1, unsigned int color) {
  if (y0 < 0) y0 = 0;
  if (y1 >= fb.h) y1 = fb.h - 1;
  for (int y = y0; y <= y1; y++)
    fb.pixels[y * fb.w + x] = color;
}

void draw_scene() {
  for (int x = 0; x < fb.w; x++) {
    // Camera space (-1 to +1)
    double cameraX = 2.0 * x / fb.w - 1.0;
    double rayDirX = cam.dirX + cam.planeX * cameraX;
    double rayDirY = cam.dirY + cam.planeY * cameraX;

    int mapX = (int)cam.x;
    int mapY = (int)cam.y;

    double deltaDistX = fabs(1.0 / rayDirX);
    double deltaDistY = fabs(1.0 / rayDirY);

    double sideDistX, sideDistY;
    int stepX, stepY;
    int hit = 0;
    int side;

    if (rayDirX < 0) {
      stepX = -1;
      sideDistX = (cam.x - mapX) * deltaDistX;
    } else {
      stepX = 1;
      sideDistX = (mapX + 1.0 - cam.x) * deltaDistX;
    }

    if (rayDirY < 0) {
      stepY = -1;
      sideDistY = (cam.y - mapY) * deltaDistY;
    } else {
      stepY = 1;
      sideDistY = (mapY + 1.0 - cam.y) * deltaDistY;
    }

    // --- DDA loop ---
    while (!hit) {
      if (sideDistX < sideDistY) {
        sideDistX += deltaDistX;
        mapX += stepX;
        side = 0;
      } else {
        sideDistY += deltaDistY;
        mapY += stepY;
        side = 1;
      }

      if (worldMap[mapY][mapX] > 0)
        hit = 1;
    }

    double perpWallDist;
    if (side == 0)
      perpWallDist = (mapX - cam.x + (1 - stepX) / 2) / rayDirX;
    else
      perpWallDist = (mapY - cam.y + (1 - stepY) / 2) / rayDirY;

    int lineHeight = (int)(fb.h / perpWallDist);
    int drawStart = -lineHeight / 2 + fb.h / 2;
    int drawEnd   =  lineHeight / 2 + fb.h / 2;

    unsigned int color = side ? 0xAAAAAA : 0xFFFFFF;
    draw_vertical(x, drawStart, drawEnd, color);
  }
}

void present(Display *d, Window w, GC gc) {
  XPutImage(d, w, gc, fb.img, 0, 0, 0, 0, fb.w, fb.h);
}

int main() {
  Display *d = XOpenDisplay(NULL);
  int s = DefaultScreen(d);
  Visual *v = DefaultVisual(d, s);
  int depth = DefaultDepth(d, s);

  Window w = XCreateSimpleWindow(
    d, RootWindow(d, s),
    0, 0, SCREEN_W, SCREEN_H, 0,
    BlackPixel(d, s), BlackPixel(d, s)
  );

  XSelectInput(d, w, ExposureMask | KeyPressMask);
  XMapWindow(d, w);
  GC gc = XCreateGC(d, w, 0, NULL);

  fb.w = SCREEN_W;
  fb.h = SCREEN_H;
  fb.pixels = calloc(fb.w * fb.h, sizeof(unsigned int));
  fb.img = XCreateImage(d, v, depth, ZPixmap, 0,
                        (char*)fb.pixels, fb.w, fb.h, 32, 0);

  XEvent e;
  while (1) {
    XNextEvent(d, &e);

    if (e.type == Expose) {
      clear_fb();
      draw_scene();
      present(d, w, gc);
    }

    if (e.type == KeyPress) {
      KeySym k = XLookupKeysym(&e.xkey, 0);
      double move = 0.2;
      double rot  = 0.1;

      if (k == XK_Escape) break;

      if (k == XK_w) {
        cam.x += cam.dirX * move;
        cam.y += cam.dirY * move;
      }
      if (k == XK_s) {
        cam.x -= cam.dirX * move;
        cam.y -= cam.dirY * move;
      }
      if (k == XK_Left || k == XK_Right) {
        double r = (k == XK_Left) ? rot : -rot;
        double oldDirX = cam.dirX;
        cam.dirX = cam.dirX * cos(r) - cam.dirY * sin(r);
        cam.dirY = oldDirX * sin(r) + cam.dirY * cos(r);
        double oldPlaneX = cam.planeX;
        cam.planeX = cam.planeX * cos(r) - cam.planeY * sin(r);
        cam.planeY = oldPlaneX * sin(r) + cam.planeY * cos(r);
      }

      clear_fb();
      draw_scene();
      present(d, w, gc);
    }
  }

  fb.img->data = NULL;
  XDestroyImage(fb.img);
  free(fb.pixels);
  XCloseDisplay(d);
  return 0;
}

